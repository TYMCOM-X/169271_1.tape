BASE 0

GLOBAL %TRUCTL

%TRUCTL

!REQUIRES OP SY JL ST WF LICENSE

FIND PJ.THIS.SYS, TOKEN(0), PNAME(0)

FIND %BYPT, %INIT.TTY, %CHOOSE, %CHR.OUT, %DATOUT, %GETNUM, %GETTOKEN, %NUMOUT
FIND %MAKE.SIXBIT, %QUERY, %LISTABLE, %SIXOUT, %SPOUT, %OUT, %GETOCT
FIND %HASH, %TRA.UFD, %UFDUPD, %GETULC, %RD.UFD

GLOBAL CH.OUT, P, NUMBER, LOC.HASH, NAME.HASH, UFD.BLK(4)

GLOBAL %CALL.UUO



LOCAL %GSYSNO, %INIT.TRU.CTL, %FIND.USER.IN.LUD, %FIND1, %GET.INFO, %MAKE.ROOM
LOCAL %CURRENT.TRUS, %GET.DUL, %GET.D.1, %MAKE.MIN, %TIME.OUT
LOCAL %FIX.TIME, %CHK.ACCESS, %CHK1.ACCESS, %LUD.UPDATE, %CHK.TIME
LOCAL %TT.FILE.OUT, %SET.TT, %CHK.DIST.MATCH, %CHK.GAN.MATCH
LOCAL %TT.SPC.FILE.OUT
LOCAL %CHK.TRA, %GET.UFD, %USER.TT, %SET.BUDGET


LOCAL STR.TEMP, TEMP, TEMP1, USER(2), LIST, SET, CH.TRU, TRUBLK(128), BUDGET, USED, CMD
LOCAL HEAD.SW, OR.SW, OR.FLG, DATLOC(3), SYS.IS, SHOULD.B
LOCAL CH.LUD, L.INDEX, L.BLK(128), LUD.SIZE, CH.IN
LOCAL ACC.USED, TRANS.TRU, TT.ACC(MAXARG)
LOCAL CH.DUL, D.INDEX, D.BLK(128), SAVE.ACC(MAXARG)
LOCAL THIS.PPN, THIS.GAN, THIS.U(2), THIS.DIST, THIS.A.S, THIS.UUN
LOCAL OPER, GOD, OPR.LIC, R.DIST, R.GAN, HIGHJ, LEGAL, THIS.SYS
LOCAL B.TOT, U.TOT, L.TOT, S.INDEX, BLK.N, SAV.TMP
LOCAL IOTAB(40), SET.TT.F, SET.C.S.F, SET.MANAGER, NO.UFD.FLG
LOCAL FROM.PPN, TO.PPN, TRANS, LEFT, FROM.TRU, TO.TRU, FROM.STR, FROM.LUD
LOCAL FROM.USER(2), TO.USER(2), ZER.FLG	!FLAG FOR LISTING UNCONTROLLED USERS ONLY
LOCAL TYM.FLG, N.TYM.FLG	!INCLUDE OR NOT INCLUDE TYMSHARE USERS

LOCAL DUL.ERR:, CHK.IN:, CHK.ERR:, END.LUD:, TRU.ERR:, ALTTYP:, TOT.END:

DEF CH.CTL(A) AS [READ.CTL(UPDATE);&
   A; SETCP(CH.TRU,0); WB(CH.TRU,6,TRUBLK); CLOSE(CH.TRU)]
DEF B.LUD AS LUD(5)/10000
DEF BUDGET.OUT AS [MSG('$BUDGET = '); NUMOUT(BUDGET _ B.LUD);&
   MSG(' TRUS FOR '); NAME.OUT]
DEF CHECK.NO.MORE.IN(A) AS [IF TEMP _ NCHV P = EOLIT OR &
   TEMP = CARRET THEN A; PCHV P]
DEF CHK.B.SET AS [IF TRU.BIT=0 THEN [MSG('$NO BUDGET IS SET FOR ');&
   NAME.OUT; GO GETCMD]]
DEF CHK.LEGAL.UUN AS IF LEGAL = 0 AND GOD = 0 THEN CMD.BAD
DEF CHK.DIST(D) AS [IF TEMP _ D = 203 THEN TEMP _ 3; IF TEMP > 10 THEN &
TEMP _ 10; CHK.UUN(TEMP)]
DEF CHK.UUN(A) AS [IF LEGAL.UUNS(A) # THIS.UUN THEN CMD.BAD]
DEF CHK.OPER AS IF OPER # 1 AND GOD = 0 THEN CMD.BAD
DEF CHK.LTCURT AS IF TRUBLK(0) # TRU.WORD THEN [MSG('$ERROR ON LTCURT.DAT$');EXIT]
DEF CMD.BAD AS [MSG('$YOU MAY NOT EXECUTE THIS COMMAND.'); GO GETCMD]
DEF CH.PJ AS IF LUD(0) = PJPPN THEN CMD.BAD
DEF COLON AS MSG(': ')
DEF CR AS CHR.OUT(CARRET)
DEF DIST AS BYT(LUD(1),8,0)
DEF D.NAME.OUT AS SIXOUT(@DUL(1),12)
DEF DONE.MSG AS MSG('$CHANGE COMPLETED.')
DEF DUL(A) AS D.BLK(A+D.INDEX)
DEF GET.PPN.FOR.JOB(J) AS CALL.UUO(SET.HALFS(J,OCT 23),OCT 41,1)
DEF GET.NAME.1(J) AS CALL.UUO(SET.HALFS(J,OCT 22),OCT 41,1)
DEF GET.NAME.2(J) AS CALL.UUO(SET.HALFS(J,OCT 21),OCT 41,1)
DEF J.M AS OCT 777777
DEF GET.USER AS [GETTOKEN(2); MAKE.SIXBIT(TOKEN,USER,12)]
DEF GET.BUDGET AS [MSG('$ENTER BUDGET(0 IF NONE): ');&
    BUDGET _ GETNUM * 10000]
DEF GET.STR AS 5 + TRU.BIT +IF INIT.BIT = 1 THEN 3 ELSE 0
DEF GET.TIME(A) AS [LOOP [GETNUM; WHILE NUMBER > 2359;&
   MSG('HOUR MUST BE LESS THAN 24:00: ')]; TRUBLK(A) _ NUMBER]
DEF FIXCP(A) AS (A-1)*128
DEF GET.NAME AS [CHECK.NO.MORE.IN(MSG('$ENTER USER NAME: '));&
      GET.USER; IF CH(TOKEN,0) = $. THEN GO GETCMD]
DEF BURRIESCI AS OCT 220740
DEF GBLOOD AS OCT 113406
DEF GOD3 AS OCT 101723	!SAL
DEF HEAD.OUT AS [OUT('$$JOB USER NAME      BUDGET LOGGED CURRENT LEFT');&
   OUT('$                   (TRUS) (TRUS)  (TRUS) (TRUS)$$')]
DEF KEEP.CP AS [TEMP _ CP(CH.LUD); TEMP - _ 128; SETCP(CH.LUD,TEMP)]
DEF INIT.BIT AS BYT(LUD(2),1,8)
DEF L.GAN AS HW(@LUD(0),0)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF LUD.READ AS [RB(CH.LUD,128,L.BLK); L.INDEX _ 0]
DEF LUD.WRIT AS [KEEP.CP; WB(CH.LUD,128,L.BLK)]
DEF NAME.OUT AS SIXOUT(@USER(0),12)
DEF NO.TRUS AS [MSG(' TRUS LEFT TO USE.$NONE CAN BE TRANSFERRED.');&
   GO GETCMD]
DEF NUMBER.IN.6(NUM) AS [IF TEMP1_NUM <0 THEN [SPOUT(TEMP1_-TEMP1,5);&
   CHR.OUT($-)] ELSE SPOUT(TEMP1,6); NUMOUT(TEMP1)]
DEF OUT.WHERE AS [MSG('$OUTPUT TO: '); GETTOKEN(0); CLOSE(CH.OUT);&
   CH.OUT _ OPEN(TOKEN,SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)]
DEF PJPPN AS OCT 6000214
DEF PROT.BAD AS [MSG('$YOU CANNOT ACCESS THAT NAME.'); GO GETCMD]
DEF READ.CTL(A) AS [CH.TRU _ OPEN('(PJ)LTCURT.DAT',DIRECT+A+WORD,TRU.ERR);&
   RB(CH.TRU,6,TRUBLK)]
DEF READ.TRU.CTL AS [READ.CTL(INPUT); CLOSE(CH.TRU); CHK.LTCURT]
DEF RES.OUT AS [IF RESTR.BIT = 0 THEN OUT('UN'); OUT('CONTROLLED')]
DEF RESTR.BIT AS BYT(SCHED,1,15)
DEF SCHED AS CALL.UUO(OCT 17 SHL 18 BOR OCT 11,OCT 41,1)
DEF SET.BUD.MSG AS [OUT('$SET BUDGET = '); NUMOUT(BUDGET/10000);&
   OUT(' FOR '); NAME.OUT]
DEF SET.HALFS(A,B) AS (-B BAND J.M BOR (A SHL 18))
DEF SET.HIGHJ AS HIGHJ _ CALL.UUO(OCT 20 SHL 18 BOR OCT 12,OCT 41,1)
DEF SET.SYS.STATUS(A) AS CALL.UUO(1 SHL 18 BOR (A BAND OCT 777777),OCT 75,1)
DEF SATURDAY AS 3
DEF SUNDAY AS 4
DEF SET.UFD(A,B,C) AS [UFD.BLK(0) _ A; UFD.BLK(1) _ B * 10000;&
   UFD.BLK(2) _ C; IF UFDUPD < 0 THEN GO GETCMD]
DEF SIZE.DEC(A) AS SIZE.LUD.ENT _ SIZE.LUD.ENT - A
DEF SIZE.INC(A) AS SIZE.LUD.ENT _ SIZE.LUD.ENT + A
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SPACE AS CHR.OUT($ )
DEF SP.CHECK AS [IF THIS.A.S=0 AND LEGAL=0 AND GOD=0 THEN CMD.BAD]
DEF SPECIAL AS 'SPECIAL'
DEF STR.MASK AS OCT 777777770000
DEF SWITCH.OUT AS [OUT('$OVERRIDE SWITCH: ');&
   IF TRUBLK(4)#0 THEN RES.OUT ELSE &
   [OUT('NOT SET'); OUT('$$SYSTEM: '); RES.OUT]]
DEF SYS.OUT AS [OUT('$SYSTEM: '); NUMOUT(THIS.SYS); CR]
DEF THIS.DATE AS CALL.UUO(0,OCT 14,0)
DEF TRUARG(TBL) AS TBL(LOCWPF+OCT 31)
DEF TRU.BIT AS BYT(LUD(2),1,31)
DEF TRU.WORD AS OCT 525252000104
DEF TYM.BIT AS BYT(LUD(3),1,14)
DEF TYM.MATCH AS (TYM.BIT=TYM.FLG)
DEF VERSION AS 23
DEF WHAT AS [MSG('$?'); GO GETCMD]

DEF HLP.CMD AS 1
DEF LST.CMD AS 2
   DEF L.BUD.CMD AS 1
   DEF L.CON.CMD AS 2
   DEF L.OVR.CMD AS 3
   DEF L.ALL.CMD AS 4
   DEF L.ZER.CMD AS 5
DEF SET.CMD AS 3
   DEF S.BUD.CMD AS 1
   DEF S.CON.CMD AS 2
   DEF S.OVR.CMD AS 3
DEF CHK.CMD AS 4
DEF TRA.CMD AS 5
DEF SYS.CMD AS 6
DEF TOT.CMD AS 7
DEF EXI.CMD AS 8
DEF SPC.CMD AS 9

DEF N.CMDS AS 8
DEF N.LISTS AS 5
DEF N.SETS AS 3

GLOBAL TABLE LEGAL.UUNS(0:10)[11(0)]

GLOBAL TABLE EXT(1:1)[SPECIAL]

GLOBAL TABLE CMDS(1:N.CMDS)&
   ['HELP','LIST','SET','CHECK','TRANSFER','SYSTAT','TOTALS','QUIT']

GLOBAL TABLE LISTS(1:N.LISTS)&
   ['BUDGET','CONTROLS','OVERRIDE','ALL','UNCONTROLLED']

START: INIT.TRU.CTL
\\->START
GETCMD: CLOSE.ALL; CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
   CR; MSG('$*'); P _ GETLINE(TEL); GETTOKEN(0)
   N.TYM.FLG _ TYM.FLG _ ZER.FLG _ ACC.USED _ 0
   IF CMD _ CHOOSE(N.CMDS,CMDS) = 0 THEN DO
	IF CHOOSE(1,EXT) = 0 THEN WHAT ELSE CMD _ SPC.CMD
   END


   DO CMD OF 1:N.CMDS + 1 	! FOR SPECIAL COMMAND

HLP.CMD: MSG('$LEGAL COMMANDS ARE: '); LISTABLE(N.CMDS,CMDS); CR

LST.CMD: CHECK.NO.MORE.IN([LISTABLE(N.LISTS,LISTS); COLON])
   GETTOKEN(0)
   WHILE LIST _ CHOOSE(N.LISTS,LISTS) = 0 THEN [CR;LISTABLE(N.LISTS,LISTS);&
	COLON; GETTOKEN(0)]

   DO LIST OF 1:N.LISTS

	L.BUD.CMD: CHK.ACCESS; CHK.B.SET; BUDGET.OUT

	L.CON.CMD: L.OVR.CMD:  READ.TRU.CTL
   IF LIST = 2 THEN DO
	MSG('$TRU CONTROL START TIME: '); TIME.OUT(TRUBLK(1))
	MSG('$TRU CONTROL STOP TIME: '); TIME.OUT(TRUBLK(2))
   END
   IF LIST = 3 OR TRUBLK(4) # 0 THEN SWITCH.OUT

	L.ALL.CMD: SP.CHECK
   L.ALL: R.DIST _ 0
   IF GOD OR LEGAL THEN DO
	IF QUERY('ALL DISTRICTS') = 0 THEN DO
	   MSG('$ENTER DISTRICT: '); R.DIST _ GETNUM
	   IF GOD = 0 THEN CHK.DIST(R.DIST)
	END ELSE R.DIST _ -1
   END
   OUT.WHERE
   DAT.OUT; SYS.OUT
   IF ZERFLG = 0 THEN OUT('$USER NAME    BUDGET$             IN TRUS$')
   CH.LUD _ OPEN('(SYS)LUD.SYS',INPUT+DIRECT+WORD,END.LUD)
   CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,DUL.ERR)
   LUD.READ; B.TOT _ 0
   LOOP DO
	IF (LUD(4)#0 AND ((ZERFLG=0 AND TRUBIT=1) OR &
	    (ZERFLG#0 AND TRU.BIT=0 AND TYM.MATCH))) THEN DO
	   IF CHK.DIST.MATCH AND GET.D.1 # 0 THEN DO
		D.NAME.OUT
		IF ZERFLG = 0 THEN [SPACE; NUMOUT(B.LUD)]
		CR
		B.TOT + _ B.LUD
	   END
	END
	L.INDEX + _ SIZE.LUD.ENT
	IF LUD(0) <= 0 THEN LUD.READ
   END
END.LUD: IF ERRNUM # EOFERR THEN GO CHK.ERR
   IF ZERFLG = 0 THEN [OUT('$TOTALS: '); REPEAT 5 SPACE; NUMOUT(B.TOT)]

	L.ZER.CMD: INC ZERFLG; SP.CHECK
   TYM.FLG _ QUERY('INCLUDE INTERNALS')
   N.TYM.FLG _ QUERY('INCLUDE NON-INTERNALS')
   IF TYM.FLG = 0 AND N.TYM.FLG = 0 THEN GO GETCMD
   GO L.ALL
	END

SET.CMD: CHECK.NO.MORE.IN([LISTABLE(N.SETS,LISTS); COLON])
   GETTOKEN(0)
   WHILE SET _ CHOOSE(N.SETS,LISTS) = 0 THEN [CR; LISTABLE(N.SETS,LISTS);&
	COLON; GETTOKEN(0)]

   DO SET OF 1:N.SETS

	S.BUD.CMD: IF GOD = 0 THEN CMD.BAD
	LOOP DO
   GET.NAME; FIND.USER.IN.LUD; CLOSE(CH.LUD)
   CH.PJ	!DON'T SET A BUDGET ON PJ
   GET.BUDGET
   LUD.UPDATE
   FIND.1
   IF SET.BUDGET = 1 THEN LUD.WRIT
   NXTB: CLOSE(CH.LUD); TT.FILE.OUT; MSG('$BUDGET SET.$')
   CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
	END

	S.CON.CMD: IF GOD = 0 AND SET.C.S.F = 0 THEN DO
	   IF OPR.LIC _ GETULC < 0 THEN GO GETCMD
	   IF BYT(OPR.LIC,1,20) # 1 THEN CMD.BAD
	   INC SET.C.S.F
   END
   CH.CTL(GET.INFO); DONE.MSG

	S.OVR.CMD: CHK.OPER
   IF GOD = 0 AND SET.MANAGER = 0 THEN DO
	IF OPR.LIC _ GETULC < 0 THEN GO GETCMD
	IF BYT(OPR.LIC,1,18) # 1 THEN CMD.BAD
	INC SET.MANAGER
   END
   OR.SW _ QUERY('SET OVERRIDE')
   DATLOC(0) _ THIS.DATE
   DATLOC(1) _ CALL.UUO(0,OCT 22,0)	!GET TIME
   DATLOC(2) _ OCT 400000
   CALL.UUO(DATLOC,-OCT 55,1)	!GET NO. OF DAYS SINCE START
   [;TEMP] _ DATLOC(0) DIVMOD 7
   IF TEMP # SATURDAY AND TEMP # SUNDAY THEN DO
	READ.TRU.CTL
	TEMP _ EXU(OCT 47,OCT 1,OCT 23)/60000
	SHOULD.B _ IF TEMP > MAKE.MIN(TRUBLK(1)) AND &
	   TEMP < MAKE.MIN(TRUBLK(2)) THEN 1 ELSE 0
   END ELSE SHOULD.B _ 0
   CH.CTL(TRUBLK(4) _ OR.SW); OR.FLG _ 0
   SYS.IS _ RESTR.BIT
   IF OR.SW = 0 AND SHOULD.B # SYS.IS THEN INC OR.FLG
   IF OR.SW # 0 AND SHOULD.B = SYS.IS THEN INC OR.FLG
   IF OR.FLG # 0 THEN DO
	TEMP1 _ SCHED
	BYT(TEMP1,1,15) _ IF BYT(TEMP1,1,15) = 0 THEN 1 ELSE 0
	SET.SYS.STATUS(TEMP1)
   END
   SWITCH.OUT
	END
	TT.FILE.OUT

CHK.CMD: CHK.ACCESS; CHK.B.SET; BUDGET.OUT; CLOSE.ALL
   GET.UFD(LUD(0),STR.TEMP _ LUD(GET.STR))
   MSG('$CURRENT TRUS USED: ')
   NUMOUT(USED _ TRUARG(IOTAB) + CURRENT.TRUS(LUD(0)))
   MSG('$TRUS REMAINING: '); NUMOUT(BUDGET - USED)

TRA.CMD: CHK.TIME
   IF RESTR.BIT # 1 THEN &
	[MSG('$THIS COMMAND MAY ONLY BE EXECUTED DURING CONTROLLED TIME.$');&
	GO GETCMD]
   CHECK.NO.MORE.IN(MSG('$USER NAME TO TRANSFER TRUS FROM: '))
   GET.USER; CHK1.ACCESS
   CHK.B.SET; GET.UFD(FROM.PPN _ LUD(0),STR.TEMP _ LUD(GET.STR))
   NAME.OUT; MSG(' HAS '); FROM.TRU _ TRUARG(IOTAB)
   FROM.STR _ LUD(GET.STR) BAND STR.MASK
   FROM.LUD _ B.LUD
   NUMOUT(LEFT _ (B.LUD - (FROM.TRU + CURRENT.TRUS(LUD(0)))))
   IF LEFT <= 0 THEN NO.TRUS
   MSG(' TRUS LEFT TO USE.$HOW MANY TRUS DO YOU WISH TO TRANSFER? ')
   LOOP DO
	P _ GETLINE(TEL)
	GETNUM
	WHILE NUMBER > LEFT OR NUMBER < 1
	   MSG('$AMOUNT MUST BE POSITIVE AND LESS THAN ')
	NUMOUT(LEFT+1); COLON
   END
   TRANS _ NUMBER
   MSG('$USER TO TRANSFER TRUS TO: '); GET.USER
   FROM.TRU + _ TRANS
   FIND.USER.IN.LUD
   MOVE 2 FROM USER TO TO.USER
   IF TRU.BIT # 1 THEN [CHK.B.SET; GO GETCMD]
   GET.UFD(TO.PPN _ LUD(0), STR.TEMP _ LUD(GET.STR))
   IF NO.UFD.FLG < 0 THEN [MSG('$THERE IS NO UFD FOR '); NAME.OUT;CR;&
	GO GETCMD]
   TO.TRU _ TRUARG(IOTAB) - TRANS
   IF TO.PPN = FROM.PPN THEN&
	[MSG('$TO AND FROM USERS MAY NOT BE THE SAME.'); GO GETCMD]
   IF TEMP _ TRA.UFD(FROM.PPN,FROM.STR,FROM.LUD-CURRENT.TRUS(FROM.PPN),&
	TO.PPN,LUD(GETSTR) BAND STR.MASK,TRANS) <0 THEN DO
	   CR
	   EIF TEMP = -1 THEN MSG('"TO" USER ERROR')
	   ORIF TEMP = -2 THEN MSG('THERE ARE NOT ENOUGHT TRUS LEFT')
	   ORIF TEMP = -3 THEN MSG('"FROM" USER ERROR')
	   ELSE MSG('ERROR IN TRANSFER')
	   MSG('.$')
	   GO GETCMD
	END
   TT.FILE.OUT
   IF ACC.USED # 0 THEN USER.TT
   MSG('$TRANSFER COMPLETED.')

SYS.CMD: SP.CHECK; IF GOD THEN R.GAN _ -1
   OUT.WHERE; DAT.OUT; SYS.OUT; SWITCH.OUT; HEAD.SW _ 0; SET.HIGHJ
   FOR TEMP _ 1 TO HIGHJ IF USER(0) _ GET.NAME.1(TEMP) # 0 THEN DO
	USER(1) _ GET.NAME.2(TEMP)
	FIND.USER.IN.LUD; CLOSE(CH.LUD)     
	IF TRU.BIT # 0 AND CHK.GAN.MATCH THEN DO
	   IF HEAD.SW = 0 THEN [HEAD.OUT; INC HEAD.SW]
	   SPOUT(TEMP,2); NUMOUT(TEMP); SPACE
	   NAME.OUT; SPACE
	   NUMBER.IN.6(B.LUD)
	   GET.UFD(LUD(0),STR.TEMP _ LUD(GET.STR))
	   NUMBER.IN.6(TRUARG(IOTAB))
	   LEFT _ CALL.UUO(TEMP SHL 18 BOR 4,OCT 41,1)/10000
	   NUMBER.IN.6(LEFT)
	   SAV.TMP _ TEMP; LEFT _ CURRENT.TRUS(LUD(0)); TEMP _ SAV.TMP
	   NUMBER.IN.6(B.LUD-LEFT-TRUARG(IOTAB))
	   TEMP1 _ CALL.UUO(SET.HALFS(TEMP,OCT 27),OCT 41,1)
	   IF HW(@TEMP1,0) = 0 THEN OUT(' JOB IS DETACHED')
	   IF GET.PPN.FOR.JOB(TEMP) # &
	     LUD(0) _ CALL.UUO(SET.HALFS(TEMP,-2),OCT 41,1) THEN DO
		IF GET.DUL # 0 THEN DO
		   CLOSE(CH.DUL)
		   OUT(' ('); D.NAME.OUT
		   CHR.OUT($))
		END
	   END
	   CR
	END
   END
   IF HEAD.SW = 0 THEN MSG('$$$NO USER WITH A BUDGET SET IS LOGGED IN.')

TOT.CMD: SP.CHECK; R.GAN _ 0
   IF GOD THEN DO
	IF QUERY('ALL GANS') = 0 THEN DO
	   MSG('$ENTER GAN: '); R.GAN _ GETOCT
	END ELSE R.GAN _ -1
   END
   OUT.WHERE
   DAT.OUT; SYS.OUT; SWITCH.OUT
   OUT('$$USER NAME     BUDGET TOTAL USED   LEFT')
   OUT('$              (TRUS)   (TRUS)     (TRUS)$$')
   CH.LUD _ OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,TOT.END)
   LUD.READ; B.TOT _ U.TOT _ LTOT _ 0
   LOOP DO
	IF TRU.BIT = 1 AND LUD(4) # 0 AND CHK.GAN.MATCH THEN DO
		IF GET.DUL # 0 THEN DO 
		   CLOSE(CH.DUL)
		   D.NAME.OUT; SPACE
		   B.TOT + _ BUDGET _ B.LUD
		   NUMBER.IN.6(BUDGET); SPACE; SPACE
		   S.INDEX _ L.INDEX; BLK.N _ CP(CH.LUD) - 128; CLOSE(CH.LUD)
		   GET.UFD(LUD(0),STR.TEMP _ LUD(GET.STR))
		   CH.LUD _ OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,TOT.END)
		   SETCP(CH.LUD,BLK.N); LUD.READ; L.INDEX _ S.INDEX
		   U.TOT + _ USED _ TRUARG(IOTAB) + CURRENT.TRUS(LUD(0))
		   NUMBER.IN.6(USED)
		   IF GET.PPN.FOR.JOB(TEMP) = LUD(0) THEN DO
			OUT(' L    ')
		   END ELSE REPEAT 6 SPACE
		   L.TOT + _ LEFT _ BUDGET-USED
		   NUMBER.IN.6(LEFT); CR
		END ELSE CLOSE(CH.DUL)
	END
	L.INDEX + _ SIZE.LUD.ENT
	IF LUD(0) <= 0 THEN LUD.READ
   END
   TOT.END: OUT('$TOTALS: '); REPEAT 5 SPACE
	NUMBER.IN.6(B.TOT); SPACE; SPACE
	NUMBER.IN.6(U.TOT); REPEAT 6 SPACE
	NUMBER.IN.6(L.TOT); CR

EXI.CMD: EXIT

SPC.CMD: IF THIS.UUN # GBLOOD AND THIS.UUN # BURRIESCI THEN WHAT
   GET.BUDGET
   MSG('$FILE NAME: '); GETTOKEN(0)
   CH.IN _ OPEN(TOKEN,SEQUEN+INPUT+CHARACTER,CHK.IN,2)
   LOOP DO
	P _ GETLINE(CH.IN); GET.USER
	LUD.UPDATE
	IF FIND.1 # 0 THEN DO
	   CH.PJ
	   IF SET.BUDGET = 1 THEN LUD.WRIT
	   TT.SPC.FILE.OUT
	END
	MSG(TOKEN); MSG('$')
	CLOSE(CH.LUD)
   END
   CHK.IN:  IF ERRNUM = FNFERR THEN [MSG('$FILE NOT FOUND.$'); GO GETCMD]
	IF ERRNUM # EOFERR THEN GO CHK.ERR

END

ALTTYP: GO GETCMD


CHK.ERR: MSG('$ERROR ON FILE - ERROR '); NUMOUT(ERRNUM); CR
DO ERRNUM OF TMFERR:CORERR
TMFERR: MSG('TOO MANY FILES OPEN')
FMDERR: MSG('BAD FILE MODE OR TYPE FOR ATTEMPTED OPERATION')
IFDERR:MSG('ILLEGAL FILE ID')
CNFERR: MSG('NEW/OLD FILE MESSAGE NOT CONFIRMED OR TYPE MODIFIER CONFLICT')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION VIOLATION')
FBSERR: MSG('FILE BUSY')
AEFERR: MSG('ALLREADY EXISTING FILE')
EOFERR: MSG('END OF FILE')
LNGERR: MSG('LINE TOO LONG')
TELERR: MSG('ILLEGAL OPERATION ON TEL')
ARGERR: MSG('BAD ARGUMENT VALUE')
CORERR: MSG('OUT OF CORE')
END
MSG('$PLEASE NOTIFY TYMSHARE Q.A. DEPARTMENT IMMEDIATELY.$'); EXIT

TRU.ERR: IF ERRNUM # FNFERR THEN GO CHK.ERR
MSG('$LTCURT.DAT NEEDS TO BE CREATED.$')
IF OPER = 0 AND GOD = 0 THEN GO CHK.ERR
CH.TRU _ OPEN('(PJ)LTCURT.DAT',DIRECT+OUTPUT+WORD,TRU.ERR)
   TRUBLK(0) _ TRU.WORD
   GET.INFO
   WB(CH.TRU,6,TRUBLK); CLOSE(CH.TRU); GO GETCMD



%INIT.TRU.CTL
IOCS(2)
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
MSG('$TRU CONTROL PROGRAM - VERSION '); NUMOUT(VERSION); CR; DATOUT
THIS.PPN _ GET.PPN.FOR.JOB(-1)
THIS.GAN _ HW(@THIS.PPN,0)
THIS.UUN _ HW(@THIS.PPN,1)
GOD _ IF THIS.UUN=BURRIESCI OR THIS.UUN=GBLOOD OR THIS.UUN=GOD3 THEN 1 ELSE 0
USER(0) _ THIS.U(0) _ GET.NAME.1(-1)
USER(1) _ THIS.U(1) _ GET.NAME.2(-1)
FIND.USER.IN.LUD
THIS.DIST _ DIST
THIS.A.S _ BYT(LUD(3),1,13)
LEGAL _ 0
FOR TEMP _ 1 TO 10 IF THIS.UUN = LEGAL.UUNS(TEMP) THEN LEGAL _ 1
OPER _ &
   BYT(CALL.UUO(SET.HALFS(-1,OCT 20),OCT 41,1),1,15)
READ.TRU.CTL
INITTTY(GETCMD)
SET.C.S.F _ SET.MANAGER _ 0
GSYSNO; THIS.SYS _ PJ.THIS.SYS
TEMP _ CHPT('ACCESS.TRU',-1)
   SETFID(SAVE.ACC,@TEMP,0,CHK.ERR)
TEMP _ CHPT('TRANS.TRU',-1)
   SETFID(TT.ACC,@TEMP,0,CHK.ERR)
RETURN
END INIT.TRU.CTL


%GET.INFO
MSG('$TRU CONTROL START TIME: ')

   GET.TIME(1)
MSG('$TRU CONTROL STOP TIME: ')
   GET.TIME(2)
RETURN
END GET.INFO



%CALL.UUO(AC,ADDR,SKPFLG)
LOCAL DIDIT:
^OCT 12 _ AC
EXU(OCT 47,OCT 12,ADDR,DIDIT)
IF SKPFLG = 1 THEN [MSG('$UUO FAILED.$'); EXIT]
DIDIT: RETURN ^OCT 12
END CALL.UUO



%MAKE.ROOM(WDS)
	!MAKE ROOM FOR AN ADDITIONAL WDS IN ENTRY
	!CREATE OVERFLOW BLOCKS IF NECESSARY
LOCAL TMP, SAVENT(20)
TMP _ SIZE.LUD.ENT
MOVE TMP FROM @LUD(0) TO SAVENT
	MOVE 128 - L.INDEX - TMP FROM @LUD(TMP) TO @LUD(0)
WHILE LUD(0) # 0 THEN L.INDEX + _ SIZE.LUD.ENT
MOVE TMP FROM SAVENT TO @LUD(0)
IF L.INDEX + SIZE.LUD.ENT + WDS < 128 THEN RETURN
LUD.SIZE _ SIZE(CH.LUD)/128
HW(@LUD(0),0) _ -1; HW(@LUD(0),1) _ LUD.SIZE + _ 1
LUD.WRIT; SETCP(CH.LUD,(LUD.SIZE+1) * 128)
L.INDEX _ 0
MOVE 128 FROM ALL 0 TO @LUD(0)
MOVE TMP FROM SAVENT TO @LUD(0)
RETURN
END MAKE.ROOM



%FIND.USER.IN.LUD
!USER NAME IN USER(0),USER(1)
CH.LUD _ OPEN('(SYS)LUD.SYS',INPUT+DIRECT+WORD,CHK.ERR)
%%FIND.1
HASH(^USER,^(USER+1))
SETCP(CH.LUD,FIXCP(LOC.HASH))
LUD.READ
WHILE NAME.HASH # LUD(4) THEN DO
   L.INDEX + _ SIZE.LUD.ENT
   IF LUD(0) = 0 THEN [MSG('$NAME NOT IN LUD.$');&
	IF CMD = SPC.CMD THEN RETURN 0 ELSE GO GETCMD]
   IF LUD(0) < 0 THEN DO
	SETCP(CH.LUD,FIXCP(HW(@LUD(1),1)))
	LUD.READ
   END
END
L.GAN _ HW(@LUD(0),0)
RETURN 1
END FIND.USER.IN.LUD


%CURRENT.TRUS(P)
LOCAL SAV.TMP,TRU.AMT
SETJ
TRU.AMT _ SAV.TMP _ 0
LOOP DO
   WHILE DEC HIGHJ>=0
   TEMP _ HIGHJ+1
   IF GET.PPN.FOR.JOB(TEMP) = P THEN DO
	TRU.AMT + _ CALL.UUO(TEMP SHL 18 BOR 4,OCT 41,1)/10000
	SAV.TMP _ TEMP
   END
END
TEMP _ SAV.TMP
RETURN TRU.AMT
END CURRENT.TRUS



%GET.DUL
CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,DUL.ERR)

%%GET.D.1
SETCP(CH.DUL,FIXCP((LUD(0) MOD 101) + 1)); RB(CH.DUL,128,D.BLK); D.INDEX_0
WHILE DUL(0) # LUD(0) THEN DO
   D.INDEX + _ 3
   IF DUL(0) = 0 THEN RETURN 0
   IF DUL(0) < 0 THEN DO
	SETCP(CH.DUL,HW(DUL(0),1)*128)
	RB(CH.DUL,128,D.BLK); D.INDEX _ 0
   END
END
RETURN DUL(0)
DUL.ERR: MSG('$ERROR IN DUL. NOTIFY Q.A.$'); CLOSE.ALL; EXIT
END GET.DUL



%MAKE.MIN(TIME)
RETURN (TIME/100*60) + (TIME - (TIME/100*100))
END MAKE.MIN



%LUD.UPDATE
LOCAL LUD.ERR:, ERR.CNT
ERR.CNT _ 10
LOOP DO
   CH.LUD _ OPEN('(SYS)LUD.SYS',DIRECT+UPDATE+WORD,LUD.ERR)
   RETURN
   LUD.ERR: IF ERRNUM # FBSERR THEN GO CHK.ERR
    CALL.UUO(10,OCT 31,0)	!SLEEP FOR 10  SEC
    WHILE DEC ERRCNT > 0
END
MSG('$(SYS)LUD.SYS IS BUSY FOR MORE THAN 1 MINUTE.')
MSG('$PLEASE CALL TYMSHARE Q.A. DEPARTMENT.$'); EXIT
END LUD.UPDATE


%TIME.OUT(TIME)
LOCAL T1,T2
[T1;T2] _ TIME DIVMOD 100
NUMOUT(T1); CHR.OUT($:); NUMOUT(T2); IF T2 = 0 THEN NUMOUT(T2)
RETURN
END TIME.OUT

%FIX.TIME(TIME)
LOCAL T1, T2
[T1;T2] _ TIME DIVMOD 100
RETURN T1 * 60 + T2
END FIX.TIME


%CHK.ACCESS
GET.NAME
%%CHK1.ACCESS
MOVE 2 FROM USER TO FROM.USER
FIND.USER.IN.LUD; CLOSE(CH.LUD)
IF CHK.TRA = 0 THEN PROT.BAD
RETURN
END CHK.ACCESS


%TT.FILE.OUT
LOCAL TT.ERR:, WRITE.IT:, ERR.CNT, NO.TT:
CLOSE(CH.OUT)
%%TT.SPC.FILE.OUT
SET.TT
ERR.CNT _ 10
LOOP DO
   CH.OUT _ OPEN(-IOTAB,DIRECT+UPDATE+CHARACTER,TT.ERR,2)
   REPEAT 0
   TT.ERR: IF ERRNUM = FNFERR THEN GO NO.TT
	IF ERRNUM # FBSERR THEN GO CHK.ERR
	CALL.UUO(10,OCT 31,0)	!SLEEP FOR 10 SEC.
	IF ERR.CNT < 0 THEN RETURN
END
SETCP(CH.OUT,SIZE(CH.OUT))
WRITE.IT: DATOUT
OUT('LOGGED INTO: '); SIXOUT(THIS.U,12); CR
DO CMD OF SET.CMD:SPC.CMD

SET.CMD: DO SET OF S.BUD.CMD:N.SETS
  S.BUD.CMD: SET.BUD.MSG
  S.CON.CMD: OUT('$CONTROL FILE CHANGED BY '); SIXOUT(PNAME,12)
	OUT('$START TIME: '); TIME.OUT(TRUBLK(1))
	OUT('$STOP TIME: '); TIME.OUT(TRUBLK(2))
  S.OVR.CMD: OUT('$OVERRIDE SWITCH CHANGED BY '); SIXOUT(PNAME,12)
	SWITCH.OUT
  END
TRA.CMD: CR; NUMOUT(TRANS); OUT(' TRUS TRANSFERRED FROM ')
   SIXOUT(@FROM.USER(0),12); OUT(' TO '); SIXOUT(@TO.USER(0),12)
SPC.CMD: SET.BUD.MSG
END
CR
CLOSE(CH.OUT)
RETURN
NO.TT: CH.OUT _ OPEN(-IOTAB,DIRECT+OUTPUT+CHARACTER,CHK.ERR,2)
  GO WRITE.IT
END TT.FILE.OUT



%USER.TT
LOCAL U.ERR:, TT.OUT:, ERR.CNT
PPNARG(TT.ACC) _ PPNARG(SAVE.ACC)
ERR.CNT _ 10
LOOP DO
   CH.OUT _ OPEN(-TT.ACC,DIRECT+UPDATE+CHARACTER,U.ERR,2)
   REPEAT 0
   U.ERR: IF ERRNUM = FNFERR THEN &
	[CH.OUT _ OPEN(-TT.ACC,DIRECT+OUTPUT+CHARACTER,CHK.ERR,2);&
	GO TT.OUT]
	IF ERRNUM # FBSERR THEN GO CHK.ERR
	CALL.UUO(10,OCT 31,0)	!SLEEP
	IF ERRCNT < 0 THEN RETURN
END
SETCP(CH.OUT,SIZE(CH.OUT))
TT.OUT: DATOUT
   OUT('LOGGED INTO: '); SIXOUT(THIS.U,12); CR; CR
   NUMOUT(TRANS); OUT(' TRUS TRANSFERRED FROM ')
   SIXOUT(@FROM.USER(0),12); OUT(' TO ')
   SIXOUT(@TO.USER(0),12); CR; CLOSE(CH.OUT)
RETURN
END USER.TT



%SET.TT
LOCAL T1,T2
TABLE NUMB(0:9)[$0,$1,$2,$3,$4,$5,$6,$7,$8,$9]
IF SET.TT.F = 1 THEN RETURN
P _ CHPT('(PJ)TRUTT',-1)
SETFID(IOTAB,@P,0,CHK.ERR)
TEMP _ THIS.DATE
[;TEMP] _ TEMP DIVMOD 31
INC TEMP
[T1;T2] _ TEMP DIVMOD 10
P _ BYPT(@TEMP,1,6)
TEMP _ 0
NCHV P _ NUMB(T1) - OCT 40
NCHV P _ NUMB(T2) - OCT 40
EXTARG(IOTAB) _ TEMP
INC SET.TT.F
RETURN
END SET.TT



%CHK.DIST.MATCH
LOCAL T
EIF GOD THEN DO
   IF R.DIST < 0 THEN RETURN 1
   IF R.DIST = DIST THEN RETURN 1
END
ORIF LEGAL THEN DO
   EIF R.DIST < 0 THEN DO
	IF T _ DIST = 203 THEN T _ 3
	IF T > 10 THEN T _ 10
	IF LEGAL.UUNS(T) = THIS.UUN THEN RETURN 1
   END
   ORIF R.DIST = 203 THEN DO
	IF R.DIST = DIST AND LEGAL.UUNS(3) = THIS.UUN THEN RETURN 1
   END
   ORIF R.DIST > 10 THEN DO
	IF R.DIST = DIST AND LEGAL.UUNS(10) = THIS.UUN THEN RETURN 1
   END
   ELSE IF R.DIST = DIST AND LEGAL.UUNS(DIST) = THIS.UUN THEN RETURN 1
END
ORIF THIS.A.S = 1 AND (THIS.GAN = L.GAN) THEN RETURN 1
ELSE IF THIS.UUN = HW(@LUD(0),1) THEN RETURN 1
RETURN 0
END CHK.DIST.MATCH


%CHK.GAN.MATCH
EIF GOD THEN DO
   IF R.GAN < 0 THEN RETURN 1
   IF R.GAN = L.GAN THEN RETURN 1
END
ORIF LEGAL THEN DO
   IF LEGAL.UUNS(DIST) = THIS.UUN THEN RETURN 1
   IF DIST=203 THEN [IF LEGAL.UUNS(3)=THIS.UUN THEN RETURN 1; RETURN 0]
   IF DIST > 10 AND LEGAL.UUNS(10) = THIS.UUN THEN RETURN 1
END
ELSE IF THIS.GAN = L.GAN THEN RETURN 1
RETURN 0
END CHK.GAN.MATCH


%CHK.TIME
READ.CTL(INPUT); CLOSE(CH.TRU)
IF HW(TRUBLK+3,1) # THIS.DATE THEN DO
   MSG('$THIS COMMAND CAN ONLY BE EXECUTED AFTER INITIALIZATION.$')
   GO GETCMD
END ELSE RETURN
END CHK.TIME


%GET.UFD(PN,STR)
LOCAL T
NO.UFD.FLG _ 0
UFD.BLK(0) _ PN
UFD.BLK(2) _ STR
IF T _ RDUFD = -1 THEN [NO.UFD.FLG _ T; T _ 0]
TRUARG(IOTAB) _ T/10000
RETURN
END GET.UFD


%CHK.TRA
LOCAL ACC.ERR:
LOCAL CH.ACC, S.USER(3)
IF FROM.USER(0)=THIS.U(0) AND FROM.USER(1)=THIS.U(1) THEN RETURN 1
EIF GOD = 1 THEN RETURN
ORIF LEGAL THEN DO
   IF DIST = 203 THEN [IF LEGAL.UUNS(3) = THIS.UUN THEN RETURN 1]
   IF LEGAL.UUNS(DIST) = THIS.UUN THEN RETURN 1
   IF DIST > 10 AND LEGAL.UUNS(10) = THIS.UUN THEN RETURN 1
END
ELSE IF THIS.A.S = 1 AND (THIS.GAN = L.GAN) THEN RETURN 1
PPN.ARG(SAVE.ACC) _ LUD(0)
CH.ACC _ OPEN(-SAVE.ACC,SEQUEN+INPUT+CHARACTER,ACC.ERR,2)
LOOP DO
   P _ GETLINE(CH.ACC)
   GETTOKEN(5); MAKE.SIXBIT(TOKEN,S.USER,12)
   IF S.USER(0) = THIS.U(0) AND S.USER(1) = THIS.U(1) THEN &
	[INC ACC.USED; RETURN 1]
END
ACC.ERR: IF ERRNUM=FNFERR THEN RETURN 0
   CLOSE(CH.ACC); IF ERRNUM=EOFERR THEN RETURN 0 ELSE GO CHK.ERR
END CHK.TRA



%GSYSNO

LOCAL CH.SYS
LOCAL SYS.ERR:

GLOBAL PJ.THIS.SYS, PJ.ACTG.SYS

DEF ACTG.BIT AS BYT(PJ.ACTG.SYS,1,30)

CH.SYS _ OPEN('(PJ)JOBS.DAT',DIRECT+INPUT+WORD,SYS.ERR)
SETCP(CH.SYS,1); PJ.THIS.SYS _ R(CH.SYS)
SETCP(CH.SYS,13)	!START SEARCHING THRU SYSTEMS
LOOP DO
   PJ.ACTG.SYS _ R(CH.SYS)
   WHILE ACTG.BIT # 1
END
PJ.ACTG.SYS _ HW(@PJ.ACTG.SYS,1)
CLOSE(CH.SYS); RETURN 1

SYS.ERR: CLOSE(CH.SYS); RETURN 0
END GSYSNO


%SET.BUDGET
IF TRU.BIT = 1 THEN DO
   IF LUD(5) _ BUDGET = 0 THEN DO	!IF BUDGET WAS SET, NOW NONE
	TRU.BIT _ 0
	MOVE 128-(L.INDEX+5) FROM L.BLK+L.INDEX+6 TO L.BLK+L.INDEX+5
	SIZE.DEC(1)
   END
END ELSE DO
   IF BUDGET # 0 THEN DO	!IF BUDGET WAS NOT SET, NOW >0
	MAKE.ROOM(1)
	TEMP _ SIZE.LUD.ENT
	TRU.BIT _ 1
	REPEAT SIZE.LUD.ENT - 4 [LUD(TEMP+1) _ LUD(TEMP); DEC TEMP]
	LUD(5) _ BUDGET
	SIZE.INC(1)
	TEMP _ LUD(GET.STR)
	SET.UFD(LUD(0),0,TEMP)
   END ELSE RETURN 0
END
RETURN 1
END SET.BUDGET

END TRUCTL
  "wj %