BASE 0

GLOBAL %RDACC


%RDACC

LOCAL TOKEN(72), FILNO

LOCAL CH.OUT,CH.IN

LOCAL P

LOCAL %CHR.OUT, %NUMOUT, %OUT, %GETTOKEN, %OCTOUT
LOCAL %PRINT.BLOCK, %CONTINUE

LOCAL CHK.ERR:


TABLE TEN(10)[1,10,100,1000,10000,100000,1000000,10000000,100000000,&
1000000000]


LOCAL TEMP, CHAR, TOKENP, DISP, IRC, I
LOCAL %FILL.IN.TOKEN


DEF SIZ.BLK AS 8
LOCAL ENTRY(SIZ.BLK)
LOCAL TYPE, SUB.TYPE, VALUE, WD, DAYS, HR, MINUTE, SEC, T1

DEF CHR.CNT AS NUMOUT(ENTRY(WD) BAND OCT 1777777777)
DEF CR AS CHR.OUT(CARRET)
DEF FINAL.CNT AS [OUT(' FINAL OUTPUT CHR = '); CHR.CNT]
DEF GET.TYPE(A) AS ENTRY(A) SHR 28
DEF MAX.TYPE AS 15
DEF READ.BLOCK AS RB(CH.IN,SIZ.BLK,ENTRY)
DEF SESSION.OUT AS [OUT(' SESSION #'); &
   NUMOUT(ENTRY(WD) BAND OCT 77777777);&
   OUT('   SUP = '); NUMOUT((ENTRY(WD) SHR 20) BAND OCT 17)]
DEF WD.OUT(A) AS [CHR.OUT(A SHR 16); CHR.OUT(A SHR 8); CHR.OUT(A)]


DEF CR AS CHR.OUT(CARRET)
DEF SPACE AS $ 
DEF PASS AS [WHILE NCHV P = SPACE THEN NULL; PCHV P]

START:	IOCS(2)
\\->START
OUT('INPUT FILE: '); GETTOKEN
CH.IN _ OPEN (TOKEN,WORD+INPUT+DIRECT,CHK.ERR)
OUT('$OUTPUT FILE: '); GETTOKEN
CH.OUT _ OPEN(TOKEN,SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
LOOP DO
   READ.BLOCK
   PRINT.BLOCK
END
CLOSE.ALL
EXIT

CHK.ERR: CLOSE.ALL; EXIT


%PRINT.BLOCK

OUT('$$   BLOCK TIME: ')
[;T1] _ ENTRY(0) DIVMOD (86400*365)
[DAYS;T1] _ T1 DIVMOD 86400
OUT (' DAY: '); NUMOUT(DAYS)
[MINUTE; SEC] _ T1 DIVMOD 60; [HR; MINUTE] _ MINUTE DIVMOD 60
OUT('   TIME: ')
NUMOUT(HR); CHR.OUT($:); NUMOUT(MINUTE); CHR.OUT($:); NUMOUT(SEC)

FOR WD _ 1 TO SIZ.BLK-1 DO
   IF TYPE _ GET.TYPE(WD) # 0 THEN [CR; NUMOUT(TYPE)]

   DO TYPE OF 1:MAX.TYPE

1: OUT(' NEW LOGIN   '); SESSION.OUT
   IF IRC _ ((ENTRY(WD) SHR 24) BAND OCT 17) # 0 THEN DO
	OUT('   IRC = '); NUMOUT(IRC)
   END
2: OUT(' PREAMBLE   ORIG NODE = ')
   NUMOUT((ENTRY(WD) SHR 16) BAND OCT 7777)
   OUT('   TERM TYPE = '); NUMOUT((ENTRY(WD) SHR 8) BAND OCT 377)
   OUT('   PORT = '); NUMOUT(ENTRY(WD) BAND OCT 377)
3: OUT(' TARGET HOST = '); NUMOUT((ENTRY(WD) SHR 16) BAND OCT 7777)
   OUT('   TARGET PORT = '); NUMOUT(ENTRY(WD) BAND OCT 177777)
4: OUT(' USER NAME: '); WD.OUT(ENTRY(WD)); CONTINUE
5: OUT(' UUN = '); OCTOUT(ENTRY(WD) BAND OCT 77777777)
   OUT('   CIR SPEED = '); NUMOUT((ENTRY(WD) SHR 24) BAND 3)
6: OUT(' NODE = '); NUMOUT(ENTRY(WD) BAND OCT 177777)
7: SESSION.OUT
8: OUT(' INPUT CHR = '); CHR.CNT
9: OUT(' OUTPUT CHR = '); CHR.CNT
10: FINAL.CNT; OUT ('  (HOST DOWN)')
11: FINAL.CNT; OUT('  (CIRCUIT ZAP FROM HOST)')
12: FINAL.CNT; OUT('  (CIRCUIT ZAP FROM USER)')
13: OUT(' PROJ CODE: '); WD.OUT(ENTRY(WD)); CONTINUE
14: TYPE _ (ENTRY(WD) SHR 24) BAND OCT 17
    SUB.TYPE _ (ENTRY(WD) SHR 16) BAND OCT 377
    VALUE _ ENTRY(WD) BAND OCT 177777
    DO TYPE OF 0:2
 0: DO SUB.TYPE OF 0:8
   0: OUT(' CIRCUIT TERMINATED BECAUSE ')
      DO VALUE OF 1:12
	1: OUT('HOST DOWN')
	2: OUT('DROPPED BY HOST')
	3: OUT('DROPPED BY USER')
	4: OUT('HOST NOT AVAILABLE')
	5: OUT('HOST DOWN')
	6: OUT('HOST SHUT')
	7: OUT('OUT OF PORTS')
	8: OUT('OUT OF CHANNELS')
	9: OUT('TERM DOES NOT MATCH AVAILABLE PORTS')
	10: OUT('CIRCUIT ORIGINATION REJECTED')
	11: OUT('USER NAME REJECTED')
	12: OUT('ILLEGAL USAGE OF FOREIGN ORIGIN')
      END
    1: OUT(' PORT = '); NUMOUT(VALUE)
    2: OUT(' LOW 4 DTE ADDRESS DIGITS '); NUMOUT(VALUE)
    6: OUT(' DNIC = '); NUMOUT(VALUE)
    7: OUT(' COLLECT/ORIGINATION ')
    8: OUT(' CIRCUIT-ORIGINATING HOST = '); NUMOUT(VALUE)
  END
 1: OUT(' INPUT PACKET COUNT = '); NUMOUT(ENTRY(WD) BAND OCT 77777777)
 2: OUT(' OUTPUT PACKET COUNT = '); NUMOUT(ENTRY(WD) BAND OCT 77777777)
    END
15: OUT(' FUTURE EXP ')
   END

END
END PRINT.BLOCK


%CONTINUE
LOCAL TYPE.NEW

LOOP DO
   IF WD+1 <= SIZ.BLK-1 THEN TYPE.NEW _ GET.TYPE(WD+1) ELSE RETURN
   IF TYPE.NEW # TYPE THEN RETURN
   WD + _ 1
   WD.OUT(ENTRY(WD))
END
END CONTINUE



%GETTOKEN
MOVE 72 FROM ALL 0 TO TOKEN
TOKENP _ CHPT(TOKEN,-1)
IF CHAR _ NCHV P = CARRET OR CHAR = EOLIT THEN P _ GETLINE(FILNO) ELSE PCHV P
FILL.IN.TOKEN; PASS; RETURN
END GETTOKEN


%FILL.IN.TOKEN
LOCAL ENDT:
WHILE CHAR _ NCHV P # CARRET AND CHAR # EOLIT THEN DO
IF CHAR > OCT 140 THEN CHAR - _ OCT 40
IF CHAR = $? THEN GO START
IF CHAR > OCT 140 THEN CHAR + _ OCT 40
NCHV TOKENP _ CHAR
END
PCHV P
ENDT: NCHV TOKENP _ EOLIT
	RETURN
END FILL.IN.TOKEN


%CHR.OUT(A)
W(CH.OUT,A BAND OCT 177)
RETURN
END CHR.OUT



%OUT(A)
	!OUTPUT A MESSAGE
TEMP _ CHPT(A,-1)
WHILE CHAR_NCHV TEMP#EOLIT THEN [IF CHAR=$$ THEN CHAR_CARRET;&
			CHR.OUT(CHAR)]
RETURN
END OUT



%NUMOUT(N)
	!OUTPUT DECIMAL NUMBER
IF N<0 THEN [CHR.OUT($-); N-_]
I_0; WHILE N>=TEN(I+1) THEN INC I
WHILE I>=0 THEN [CHR.OUT($0+N/TEN(I)); N_N MOD TEN(I); DEC I]
RETURN
END NUMOUT


%OCTOUT(N)
	!OUTPUT AN OCTAL HALF WORD
DISP _ BITS.PER.WORD/2
WHILE DISP > 0 THEN [DISP-_3; CHR.OUT($0+BYT(N,3,DISP))]
RETURN
END OCTOUT



END RDACC
